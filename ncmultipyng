#! /usr/bin/python2

#######################################################################
# This file is part of ncmultipyng
#
# Copyright (C) 2014 Nicolas Pillot
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#######################################################################

import argparse
import re
import subprocess
import time
import os
import array
import curses
import sys

#######################################################################
# Target host
#######################################################################

# host class to store target information
class Host:

	# ipv4 and ipv6 regexp courtesy of
	# http://www.sroze.io/2008/10/09/regex-ipv4-et-ipv6/
	_pattern_ipv4 = (
		"("
			"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\."
			"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\."
			"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\."
			"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
		")"
	)
	_pattern_ipv6 = (
		"("
			"("
				"([0-9A-Fa-f]{1,4}:){7}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){6}"
				":"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){5}"
				":"
				"([0-9A-Fa-f]{1,4}:)?"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){4}"
				":"
				"([0-9A-Fa-f]{1,4}:){0,2}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){3}"
				":"
				"([0-9A-Fa-f]{1,4}:){0,3}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){2}"
				":"
				"([0-9A-Fa-f]{1,4}:){0,4}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){6}"
				"((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}"
				"(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b)"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){0,5}:"
				"((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}"
				"(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b)"
			")|"
			"("
				"::"
				"([0-9A-Fa-f]{1,4}:){0,5}"
				"((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}"
				"(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b)"
			")|"
			"("
				"[0-9A-Fa-f]{1,4}"
				"::"
				"([0-9A-Fa-f]{1,4}:){0,5}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"::"
				"([0-9A-Fa-f]{1,4}:){0,6}"
				"[0-9A-Fa-f]{1,4}"
			")|"
			"("
				"([0-9A-Fa-f]{1,4}:){1,7}"
				":"
			")"
		")"
	)
	_re_ipv4 = re.compile(_pattern_ipv4 + "$")
	_re_ipv6 = re.compile(_pattern_ipv6 + "$", re.IGNORECASE)

	# constructor
	def __init__(self, string):
		self.address = None
		self.version = None
		self.process = None
		self.nextpoll = None
		self.results = array.array('c')
		self._parse_ip(string)

	# print
	def __repr__(self):
		return "Host(address=%s,version=%s)" % (self.address, self.version)

	# parse ip
	def _parse_ip(self, string):
		result = self._re_ipv4.match(string)
		if result is not None:
			self.version = 4
			self.address = result.group()
			return
		result = self._re_ipv6.match(string)
		if result is not None:
			self.version = 6
			self.address = result.group()
			return
		message = "%s is not a valid host definition" % string
		raise argparse.ArgumentTypeError(message)

	# finished process
	def finished(self,retcode,args):
		if retcode == 0: # success
			self.results.append('|');
		else:
			self.results.append('.');

	# spawn process
	def spawn(self, timeout):

		# check result of running or already finished child
		if self.process is not None:
			retcode = self.process.poll()
			if retcode is None:
				return
			self.finished(retcode,args)
			self.process = None

		# check time interval before respawning
		curtime = time.time()
		if self.nextpoll is not None and curtime < self.nextpoll:
			return
		self.nextpoll = curtime + timeout

		# spawn a child process
		if self.version == 6:
			cmd = "ping6"
		else:
			cmd = "ping"
		if timeout <= 0:
			timeout = 1
		params = [
			cmd,
			"-q", "-n",
			"-W", str(timeout),
			"-c", "1",
			self.address
		]
		with open(os.devnull, "w") as f:
			self.process = subprocess.Popen(params,stdout=f,stderr=f)

#######################################################################
# Command line arguments
#######################################################################

class Arguments:

	def range_integer(self, parser, string, name, mini=None, maxi=None):
		value = int(string)
		if mini is not None and value < mini:
			parser.error(
				"%s=%s is below the minimum value of %i"
				% (name, string, mini)
			)
		if maxi is not None and value > maxi:
			parser.error(
				"%s=%s is above the maximum value of %i"
				% (name, string, maxi)
			)
		return value

	def __init__(self):
		parser = argparse.ArgumentParser()
		parser.add_argument(
			"host",
			help = "target host definition (IPv4/IPv6)",
			action = "store",
			nargs = "+",
			type = lambda x: Host(x)
		)
		parser.add_argument(
			"-i",
			help = "polling interval in seconds",
			action = "store",
			default = 3,
			type = lambda x:
				self.range_integer(
					parser, x,
					"-i interval", 1, None
				)
		)
		parser.add_argument(
			"-n",
			help = "minimum number of samples to display",
			action = "store",
			default = 5,
			type = lambda x:
				self.range_integer(
					parser, x,
					"-n numsamples", 1, None
				)
		)
		parser.add_argument(
			"-r",
			help = "ncurses interface refresh delay in milliseconds",
			action = "store",
			default = 200,
			type = lambda x:
				self.range_integer(
					parser, x,
					"-r refresh_delay_in_ms", 0, None
				)
		)
		self.data = parser.parse_args()

	# print
	def __repr__(self):
		return "Arguments=%s" % self.data

#######################################################################       
# Interface
#######################################################################

class Interface:

	# constructor
	def __init__(self, win, args):
		self.stdscr = win
		self.interval_ui = args.r
		self.stdscr.nodelay(True)
		curses.curs_set(False)

	# handle input
	def handleinput(self):
		key = self.stdscr.getch()
		if key == curses.ERR:
			pass
		elif key == ord('q'):
			sys.exit(0)

	# decoration
	def decoration(self):
		self.stdscr.box()

	# display screen
	def display(self):
		self.stdscr.addstr(0,0, str(self.stdscr.getmaxyx())
			+ " " + str(curses.COLOR_PAIRS)
			+ " " + str(curses.COLORS)
		)
		self.stdscr.move(1,1)
		for i in xrange(1, curses.COLOR_PAIRS):
			txt = str(i)
			if i < 10:
				txt = "0" + txt
			self.stdscr.addstr(txt + " ")
			self.stdscr.addstr(txt + " ", curses.color_pair(i))
		self.stdscr.addstr( 4,1,"NORMAL")
		self.stdscr.addstr( 5,1,"BLINK",curses.A_BLINK)
		self.stdscr.addstr( 6,1,"BOLD",curses.A_BOLD)
		self.stdscr.addstr( 7,1,"DIM",curses.A_DIM)
		self.stdscr.addstr( 8,1,"REVERSE",curses.A_REVERSE)
		self.stdscr.addstr( 9,1,"STANDOUT",curses.A_STANDOUT)
		self.stdscr.addstr(10,1,"UNDERLINE",curses.A_UNDERLINE)

	# sleep for a while
	def sleep(self):
		curses.napms(self.interval_ui)

	# interface cycle
	def update(self):
		self.handleinput()
		self.stdscr.erase()
		self.decoration()
		self.display()
		self.stdscr.refresh()
		self.sleep()

#######################################################################
# Application
#######################################################################

class Application:

	# constructor
	def __init__(self, win, args):
		self.hosts = args.host
		self.interval_ping = args.i
		self.interface = Interface(win, args)

	# ping all addresses
	def pingall(self):
		for host in self.hosts:
			host.spawn(self.interval_ping)

	# main loop
	def run(self):
		while True:
			self.pingall()
			self.interface.update()

#######################################################################
# main
#######################################################################

def main(win, args):
	app = Application(win, args.data)
	app.run()

try:
	args = Arguments()
	curses.wrapper(main, args)
except (KeyboardInterrupt, SystemExit):
	pass
